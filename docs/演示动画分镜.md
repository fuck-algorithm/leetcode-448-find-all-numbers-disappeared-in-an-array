# 算法动画分镜脚本：找到所有数组中消失的数字（原地修改法）

## 技术架构规范

### 组件划分 UML 图

```
+-------------------+         +-----------------------+
| D3CanvasComponent |         | ControlPanelComponent |
|-------------------|         |-----------------------|
| - svgRef: Ref     |         | - playButton: Ref     |
| - data: Array     |         | - speedSlider: Ref    |
| - animations: []  |         | - resetButton: Ref    |
|-------------------|         |-----------------------|
| + render()        |         | + handlePlay()        |
| + update()        |         | + adjustSpeed()       |
| + animateFrame()  |         | + resetAnimation()    |
+-------------------+         +-----------------------+
        ^                           |
        |                           |
        +---------------------------+
```

### 状态管理类型声明

```typescript
// Redux State 类型
interface AnimationState {
  currentStep: number;
  isPlaying: boolean;
  animationSpeed: number;
  numsSnapshot: number[][];
  highlightedIndex: number | null;
  operationLog: string[];
}

// Action 类型
type AnimationAction =
  | { type: 'UPDATE_STEP'; payload: number }
  | { type: 'TOGGLE_PLAY' }
  | { type: 'SET_SPEED'; payload: number }
  | { type: 'HIGHLIGHT_INDEX'; payload: number | null }
  | { type: 'ADD_LOG'; payload: string };
```

### 性能约束

- 关键帧渲染耗时：<16ms/帧（使用 D3.js 的 requestAnimationFrame）
- 大数据量场景：启用 Web Workers 进行数据预处理
- 内存管理：每 100 步自动清理一次未使用的动画数据

---

## 分镜脚本

### 镜头 1-原地修改法-初始化阶段

**视觉焦点**
- 画布元素：绘制水平排列的矩形数组，每个矩形代表数组元素
  - 初始状态：nums = [4,3,2,7,8,2,3,1]
  - 颜色：浅灰色背景，数字为深灰色
  - 尺寸：宽度固定为 60px，高度根据数值映射（40px-120px）
- 视口控制：初始缩放比例 1:1，居中显示整个数组

**交互逻辑**
- 用户事件：点击数组元素显示数值详情
- 动画过渡：弹性缓动（d3.easeElasticOut），持续时间 800ms

**注释系统**
- 动态标注：在数组上方显示标题 "原数组状态"（坐标 0, -30）
- 语音解说：0:00-0:05 "我们面对的数组包含 n 个整数，范围在 [1, n] 之间"

### 镜头 2-原地修改法-遍历开始

**视觉焦点**
- 画布元素：
  - 指针动画：蓝色箭头指向第一个元素（4）
  - 数值 4 变为高亮蓝色
- 视口控制：平移至数组起始位置，轻微放大（缩放 1.2:1）

**交互逻辑**
- 用户事件：拖拽可暂停动画并查看当前状态
- 动画过渡：线性缓动（d3.easeLinear），持续时间 600ms

**注释系统**
- 动态标注：LaTeX 渲染公式 "x = (num - 1) % n"（坐标 200, 50）
- 语音解说：0:05-0:12 "遍历数组，遇到每个数 x，我们计算其对应索引位置"

### 镜头 3-原地修改法-标记阶段

**视觉焦点**
- 画布元素：
  - 索引 3（对应 x-1=3）的矩形边框变为红色虚线
  - 数值 7 开始闪烁（通过透明度变化实现）
  - 添加动画路径：蓝色箭头从索引 0 指向索引 3
- 视口控制：跟随焦点元素移动，保持标记区域居中

**交互逻辑**
- 用户事件：悬停在路径上显示详细操作信息
- 动画过渡：贝塞尔缓动（d3.easePolyIn），持续时间 1000ms

**注释系统**
- 动态标注：显示操作说明 "nums[3] += n"（坐标 300, 100）
- 语音解说：0:12-0:20 "将对应位置的数值增加 n，标记该数字存在过"

### 镜头 4-原地修改法-数组更新

**视觉焦点**
- 画布元素：
  - nums[3] 的值从 7 变为 7+n（动画显示数值增长）
  - 增长后的数值颜色变为绿色
- 视口控制：短暂放大该元素（缩放 1.5:1）

**交互逻辑**
- 用户事件：点击元素显示数值变化历史
- 动画过渡：二次缓动（d3.easeQuadOut），持续时间 800ms

**注释系统**
- 动态标注：LaTeX 渲染更新公式 "nums[x] = nums[x] + n"（坐标 150, 200）
- 语音解说：0:20-0:28 "更新后的数值将大于 n，这是我们后续判断的依据"

### 镜头 5-原地修改法-完成所有标记

**视觉焦点**
- 画布元素：
  - 所有被标记的位置显示绿色边框
  - 未被标记的位置（5 和 6）显示红色边框
- 视口控制：恢复原始视图，显示整个数组

**交互逻辑**
- 用户事件：点击对比按钮显示原始数组与标记后数组的差异
- 动画过渡：回弹缓动（d3.easeBackOut），持续时间 1200ms

**注释系统**
- 动态标注：显示统计信息 "已标记位置：0,1,2,3,4,6,7"（坐标 50, 300）
- 语音解说：0:28-0:35 "完成所有标记后，我们即将开始识别缺失的数字"

### 镜头 6-原地修改法-识别缺失数字

**视觉焦点**
- 画布元素：
  - 指针依次检查每个位置
  - nums[4] 和 nums[5] 保持原始值（≤n），显示红色高亮
- 视口控制：跟随指针移动，轻微放大当前检查位置

**交互逻辑**
- 用户事件：暂停时可查看详细比较逻辑
- 动画过渡：弹性缓动（d3.easeElasticInOut），持续时间 700ms

**注释系统**
- 动态标注：显示判断条件 "if (nums[i] <= n)"（坐标 250, 150）
- 语音解说：0:35-0:45 "检查每个位置，如果数值仍 ≤n，说明对应数字 i+1 未出现"

### 镜头 7-原地修改法-结果收集

**视觉焦点**
- 画布元素：
  - 收集到的缺失数字 5 和 6 显示在结果数组中
  - 结果数组元素带有绿色对勾动画
- 视口控制：平移至结果区域，适当放大

**交互逻辑**
- 用户事件：点击结果元素显示其在原数组中的缺失位置
- 动画过渡：指数缓动（d3.easeExpOut），持续时间 900ms

**注释系统**
- 动态标注：显示最终结果 "[5,6]"（坐标 400, 50）
- 语音解说：0:45-0:52 "最终找到的缺失数字是 5 和 6，这就是我们的答案"

---

## 多解法差异对比

| 步骤          | 暴力解法（哈希表） | 原地修改法（优化空间） | 数组标记法（变体） |
|---------------|--------------------|------------------------|--------------------|
| 初始化        | 红色：创建哈希表   | 绿色：直接使用原数组   | 蓝色：复制数组     |
| 标记过程      | 红色：哈希表记录   | 绿色：值+n 标记        | 蓝色：负数标记     |
| 空间复杂度    | 红色：O(n)         | 绿色：O(1)             | 蓝色：O(n)         |
| 时间复杂度    | 红色：O(n)         | 绿色：O(n)             | 蓝色：O(n)         |
| 数组修改      | 红色：不修改原数组 | 绿色：修改原数组       | 蓝色：修改复制数组 |
| 恢复原数组    | 红色：可直接使用   | 绿色：需取模恢复       | 蓝色：需取绝对值   |

---

## 复用组件标识

- **通用数组组件**：所有解法共享基础数组可视化
- **指针动画组件**：复用遍历指示逻辑
- **结果收集组件**：复用结果展示逻辑
- **操作日志组件**：复用步骤记录系统

---

## 交付文档结构

```
docs/
├── 原地修改法/
│   ├── 初始化阶段/
│   │   ├── 关键帧1.json
│   │   ├── 关键帧2.json
│   │   └── SVG示意图.svg
│   ├── 遍历阶段/
│   │   ├── ...
│   └── ...
├── 哈希表解法/
│   ├── ...
└── 测试用例/
    ├── 动画时序测试.ts
    ├── 数据快照验证.ts
    └── 交互流程测试.ts
```

---

## Jest 单元测试用例模板

```javascript
// 动画时序校验
test('原地修改法动画时序正确', () => {
  const animation = new InPlaceModificationAnimation([4,3,2,7,8,2,3,1]);
  animation.play();
  
  expect(animation.getStepDuration(0)).toBeLessThanOrEqual(800);
  expect(animation.getTotalSteps()).toBe(8);
});

// 数据快照验证
test('标记阶段数据正确', () => {
  const snapshot = InPlaceModificationAnimation.generateDataSnapshot(3);
  expect(snapshot[3]).toBeGreaterThan(8);
  expect(snapshot[4]).toBeLessThanOrEqual(8);
});
```

---

这个分镜脚本按照您的要求详细描述了每个动画阶段的视觉、交互和注释元素，同时提供了技术实现规范和测试方案。整个系统设计考虑了响应式布局、无障碍访问和工程化部署要求。